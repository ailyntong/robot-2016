#include "elevator_controller.h"
#include "elevator_constants.h"
#include "muan/control/state_space_plant.h"
#include "muan/control/control_utils.h"
#include "muan/utils/math_utils.h"
#include <iostream>

ElevatorController::ElevatorController(Time dt)
    : observer_(dt),
      length_controller_(60 * V / m, 30 * V / m / s, 0 * V / m * s) {
  controller_.SetGains(ElevatorConstants::K);
  observer_.SetGains(ElevatorConstants::L);
  observer_.SetPlant(muan::c2d(ElevatorConstants::A_c, ElevatorConstants::B_c,
                               ElevatorConstants::C_c, dt));
  current_displacement_ = 0 * m;
  current_goal_ = 0 * m;
}

Voltage ElevatorController::UpdateSS(Length displacement, bool enabled) {
  std::cout << displacement.to(m) << std::endl;
  current_displacement_ = displacement;
  auto u = controller_.Calculate(observer_.GetX());
  if (!enabled) u(0) = 0;
  if (u(0) > 2) {
    u(0) = 2;
  } else if (u(0) < -2) {
    u(0) = -2;
  }
  observer_.Update(u, muan::as_matrix<1, 1>({{displacement.to(m)}}));
  return u(0) * V;
}

void ElevatorController::SetGoalSS(Length goal) {
  current_goal_ = goal;
  controller_.SetGoal(muan::as_matrix<2, 1>({{goal.to(m)}, {0}}));
}

Voltage ElevatorController::Update(Time dt, Length displacement, bool enabled) {
  current_displacement_ = displacement;
  Voltage v =
      length_controller_.Calculate(dt, (current_goal_ - displacement));
  v = muan::Cap(v, -12 * V, 12 * V);
  if (!enabled) v = 0*V;
  return v;
}
void ElevatorController::SetGoal(Length goal) { current_goal_ = goal; }

Eigen::Matrix<double, 2, 1> ElevatorController::GetObservedState() {
  return observer_.GetX();
}

bool ElevatorController::IsDone() {
  return (muan::abs(current_goal_ - current_displacement_)).to(m) <
         ElevatorConstants::maxDisplacement;
}
